SELECT * FORM EMP
WHERE EMP_ID=150

CREATE INDEX I_EMP ON EMP (EMP_ID)

Требуют доп ресурсы, вешаются только на те поля, которые часто
используются (WHERE, JOIN, SORT BY)

Хеш функция

1) Считаем хеш от запрошенного значения
2) по Хешу находим rowid соответсвующих сток
3) Обращаемся к этим стокам

Важно, иденкс работает только на равенство, т.к. сортировки значений 
индексируемых полей и их хешей не совпадают

Коллизия все же может возникать!

Дополнительно отслеживается состояние дерева (балансировка)

Не стоит создавать индексы на 
1) Небольшие таблицы
2) На столбцы с длинными данными
3) Если столбцы, по которым индексы, часто обновляются


ТЕРРАДАТА
- Primary index (ключ распределения, по которому распределены
данные по нодам)

Нужно, чтобы на один узел попали все договора одного клиента. Тогда 
индексы имеют смысл. Но следует подумать о равномерности распределения 
данных. Если данных слишком мало - их дублируют. Большие таблицы перераспределются.
- Join Index 
Можно влкючить в индекс нескоко полей. (или поместить в индекс всю таблицу). Такие индексы
называются "Кластерными индексами"

ПАРТИЦИОНИРОВАНИЕ
секционирование - хранение таблицы БД отдельными секциями по значениям полей.
Благодаря этому можно быстро выбрать нужные секции.

CREATE TABLE TOY (
    TOY_ID INTEGER,
    TOY_NAME VARCHAR2(10),
    COLOUR VARCHAR2(10))
PARTITION BY LIST (COLOUR) (
    PARTITION P_YELLOW VALUES ('YELLOW'),
    PARTITION P_RED VALUES ('RED'),
    PARTITION P_GREEN VALUES ('GREEN')
);

SELECT *
FROM TOY
WHERE COLOUR = 'RED';

Партиции не занимают дополнительное место, только метаданные.
Не стоит перебарщивать с партициями (65К штук)

Неразмеченные партиции (неподходящие условия)
Нужно уточнять поведения СУБД по этому поводу
Возможно выполнение запроса с ошибками

Можем быстро профильтровать партицию, изменить данные в ней, подменить.

Использование партиции с Parquet позволяет удалить часть данных, что невозможно при стандартном поведении parquet.

Обработка запроса 
1 Проверка синтаксиса
2 "Смысловая" проверка (сущетсвует ли вообще таблица, есть ли права)
3 Есть ли сохраненный план запроса?
4 Генерируется новый план запроса
5 

На что смотрим в плане?
Метод доступа к данным в таблице
Порядок соединения таблиц
Методы соединения таблиц

Оценки оптимизатора:


Методы доступа:
- TABLE ACCESS FULL, или FULL SCAN – полное сканирование всей таблицы
- TABLE ACCESS BY INDEX ROWID – получаем строки через индекс
- PARTITION – сканирование одной или нескольких партиций таблицы
- INDEX SCAN – сканирование индекса, к таблице не обращаемся

Методы соединения
- Nested loops – вложенные циклы
- Merge join – слияние
- Hash join – соединение по хешу

--- Hash join
Для каждой строки меньшей таблицы считаем хеш от столбцов, по которым соединяем.
Т.е. строим по меньшей таблице хеш-таблицу.
Затем проходимся по строкам большей таблицы, считаем хеш от соединяемых столбцов и находим соответствие в меньшей таблице

Преимущества:
быстрый способ соединения. Для пары «большая таблица – маленькая таблица» – еще и не сильно затратный.
 
Недостатки:
Условием соединения может быть только равенство.

Нужна память для строящейся хеш-таблицы. Больше входная таблица – больше памяти понадобится.

Нельзя быстро получить первые строки результата – нужно как минимум дождаться построения хеш-таблицы.


--- Статистики???
Собранная базой информация по таблице/индексу о:
- количестве строк таблицы/индекса
- распределении значений полей

Когда оптимизатор генерирует план запроса – он использует
статистики.
Статистики необходимо периодически собирать!
Без правильных статистик он может выбрать неоптимальный план


-- команда сбора статистики (Oracle)BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(OWNNAME => 'SOME_USER',
        TABNAME => 'TOY');
END;


Хинты - Подсказки оптимизатору выполнять какие-нибудь шаги определенным образом.
В Oracle пишутся в комментарии как /* +название хинта */:
SELECT /* + взболтать, но не смешивать */
    *
FROM DRINKS
WHERE DRINK_TYPE = 'Мартини'


 
